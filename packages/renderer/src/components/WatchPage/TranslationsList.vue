<template>
  <div>
    <template
      v-for="group of groups"
      :key="group.title"
    >
      <h4 class="mt-3 px-3">
        {{ group.title }}
      </h4>
      <play-list
        class="my-3"
        :aria-label="group.title"
        :items="group.playListItems"
        :selected-item-id="selectedTranslation.id"
        @item-click="onManualSelect"
      />
    </template>
  </div>
</template>

<script lang="ts">
import type {DeepReadonly, PropType} from 'vue';
import {computed, defineComponent, toRaw} from 'vue';
import {useRoute} from 'vue-router';
import type {Translation} from '/@/utils/videoProvider';
import {useBrowserLocation} from '@vueuse/core';
import {savePreferredTranslation} from '/@/utils/translationRecomendations';
import {formatList} from '/@/utils/formatList';
import type {PlayListItem} from '/@/components/WatchPage/PlayList.vue';
import PlayList from '/@/components/WatchPage/PlayList.vue';
import {trackEvent} from '/@/utils/telemetry';


export default defineComponent({
  name: 'TranslationsList',
  components: {PlayList},
  props: {
    translations: {
      type: Array as PropType<DeepReadonly<Translation[]>>,
      required: true,
    },
    selectedEpisodeNum: {
      required: true,
      type: Number,
    },
  },
  setup(props) {
    const route = useRoute();
    const selectedTranslation = computed(() => props.translations.find(e => String(e.id) === route.params.translationId) || props.translations[0]);

    const currentLocation = useBrowserLocation();


    const groups = computed<{title: string, playListItems: PlayListItem[]}[]>(() => {
      const groups = new Map<string, DeepReadonly<Translation>[]>();

      for (const translation of props.translations) {
        const g = groups.get(translation.type) || [];
        g.push(translation);

        groups.set(translation.type, g);
      }

      const translationToPlayListItem = (t: DeepReadonly<Translation>): PlayListItem => {

        let badges: PlayListItem['badges'] = [];

        if (t.qualityType !== 'tv') {
          badges.push({
            style: 'success',
            text: t.qualityType.toLocaleUpperCase(),
          });
        }

        if (!t.censored) {
          badges.push({
            style: 'danger',
            text: 'CE',
          });
        }

        return {
          id: t.id,
          label: t.title,
          title: formatList(t.author.members),
          url: {params: {translationId: t.id, episodeNum: props.selectedEpisodeNum}},
          badges,
        };
      };

      const result = [];
      {
        let translations = groups.get('voice');
        if (translations) {
          result.push({title: 'Озвучка', playListItems: translations.map(translationToPlayListItem)});
        }
      }

      {
        let translations = groups.get('sub');
        if (translations) {
          result.push({title: 'Субтитры', playListItems: translations.map(translationToPlayListItem)});
        }
      }

      return result;
    });



    // Сохранение выбранного перевода в предпочтениях
    const saveToPreferred = (translation: DeepReadonly<Translation>) => {
      savePreferredTranslation(Number(route.params.seriesId), toRaw(translation) as Translation);
    };


    const onManualSelect = (item: PlayListItem) => {
      const targetTranslation = props.translations.find(t => t.id === item.id);
      if (targetTranslation) {
        saveToPreferred(targetTranslation);
      }
      trackEvent({ec: 'PlayList Manual Select', ea: 'Translation Select'});
    };



    return {selectedTranslation, groups, currentLocation, onManualSelect};
  },
});
</script>
