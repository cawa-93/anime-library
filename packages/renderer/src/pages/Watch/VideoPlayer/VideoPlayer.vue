<script lang="ts" setup>
import type {PropType} from 'vue';
import {computed, defineAsyncComponent, onBeforeUnmount, onMounted, onUnmounted, ref, watch, watchEffect} from 'vue';
import {syncRef, useEventListener, useIdle, useMediaControls, useStorage} from '@vueuse/core';
import type {Video, VideoTrack} from '/@/utils/videoProvider';
import LoadingSpinner from '/@/components/LoadingSpinner.vue';
import {useMediaHotKeys} from '/@/use/useMediaHotKeys';
import TimeCode from '/@/pages/Watch/VideoPlayer/time-code.vue';
import VolumeControl from '/@/pages/Watch/VideoPlayer/VolumeControl.vue';
import ProgressBar from '/@/pages/Watch/VideoPlayer/ProgressBar.vue';
import TogglePipButton from '/@/pages/Watch/VideoPlayer/TogglePipButton.vue';
import {isMediaMetadataLoaded} from '/@/use/isMediaMetadataLoaded';
import {getFramesFromVideo} from '/@/pages/Watch/VideoPlayer/getFramesFromVideo';
import {HOUR, SECOND_MS} from '/@/utils/time';
import {trackTime} from '/@/utils/telemetry';
import type {ActionsHandlers as UseMediaSessionHandlers} from '/@/pages/Watch/VideoPlayer/useMediaSession';
import {useMediaSessionActionsHandlers} from '/@/pages/Watch/VideoPlayer/useMediaSession';
import {isEnabled as isTimelineThumbnailsEnabled} from '/@/pages/Options/settingTimelineThumbnails';


const LibAssSubtitlesRenderer = defineAsyncComponent(() => import('/@/pages/Watch/VideoPlayer/LibAssSubtitlesRenderer.vue'));

const props = defineProps({
  currentTime: {
    type: Number,
    require: false,
    default: 0,
  },
  duration: {
    type: Number,
    require: false,
    default: 0,
  },
  video: {
    type: Object as PropType<Video>,
    required: false,
    default: undefined,
  },
  hasNextEpisode: {
    type: Boolean,
    required: false,
    default: false,
  },
  inFullscreen: {
    type: Boolean,
    required: true,
  },
});

const emit = defineEmits({
  'source-error': null,
  'update:currentTime': (value: unknown) => typeof value === 'number' && !isNaN(value) && isFinite(value),
  'update:duration': (value: unknown) => typeof value === 'number' && !isNaN(value) && isFinite(value),
  'go-to-next-episode': null,
  'update:controlsVisible': null,
  'update:inFullscreen': null,
});



/**
 * Массив доступных вариантов качества видео
 */
const qualities = computed(() => props.video ? [...props.video.qualities.keys()] : []);

const maxQuality = computed(() => Math.max(...qualities.value));
/**
 * Выбранное качество видео
 */
const selectedQuality = ref(maxQuality.value);

/**
 * Автоматически переключатся на максимальное качество при смене видео
 */
watch(qualities, () => selectedQuality.value = maxQuality.value);


/**
 * Источник для видео выбранного качества
 */
const videoSource = computed(() =>
  props.video
    ? ((
        props.video.qualities.get(selectedQuality.value)
        || props.video.qualities.get(maxQuality.value)
      )
      +
      '#t=' + props.currentTime)
    : '',
);



const videoElement = ref<HTMLVideoElement>();
useEventListener(videoElement, 'leavepictureinpicture', () => window.focus());
const {isLoaded: isVideoLoaded} = isMediaMetadataLoaded(videoElement);

/**
 * Выполнять загрузку видео при изменении ссылок на ресурсы
 */
watch(videoSource, (newSrc, oldSrc) => {
  const newSrcWithoutFragment = newSrc.split('#')[0];
  const oldSrcWithoutFragment = oldSrc.split('#')[0];

  if (newSrcWithoutFragment.toLowerCase() !== oldSrcWithoutFragment.toLowerCase()) {
    videoElement.value?.load();
  }
});

// Передать ошибку родителю если не удалось загрузить видео
const errorHandler = (event: Event) => {
  if (videoElement.value?.currentSrc) {
    emit('source-error', selectedQuality.value, event);
  }
};


/**
 * Массив треков для субтитров
 */
const tracks = computed<VideoTrack[]>(() => {
  if (!props.video?.tracks || props.video.tracks.length === 0) {
    return [];
  }
  return [...new Map(props.video.tracks.map(t => [t.src, t])).values()];
});

const isSubtitlesEnabled = ref(true);

const {
  playing,
  duration: $duration,
  currentTime: $currentTime,
  buffered,
  waiting,
  volume: videoVolume,
  muted: videoMuted,
} = useMediaControls(videoElement);

const volume = useStorage('volume', videoVolume.value);
const muted = useStorage('muted', videoMuted.value);

onMounted(() => {
  syncRef(volume, videoVolume, {immediate: true});
  syncRef(muted, videoMuted, {immediate: true});
});

//
// переключение полноэкранного режима
// const mainEl = ref();
// onUnmounted(() => mainEl.value = document.querySelector('main'));
// const {isFullscreen, toggle: toggleFullscreen} = useFullscreen(mainEl);

const toggleFullscreen = () => emit('update:inFullscreen', !props.inFullscreen);

//
// Быстрая перемотка
const DEFAULT_SEEK_SPEED = 5;
const seek = (speed = DEFAULT_SEEK_SPEED) => $currentTime.value = Math.max(
  0,
  Math.min($currentTime.value + speed, $duration.value));

//
// Работа с горячими клавишами
useMediaHotKeys({
  playingToggle: () => playing.value = !playing.value,
  playingPause: () => playing.value = false,
  volumeDown: e => {
    volume.value = e.shiftKey ? 0 : Math.max(0, volume.value - 0.05);
    muted.value = false;
  },
  volumeUp: e => {
    volume.value = e.shiftKey ? 1 : Math.min(1, volume.value + 0.05);
    muted.value = false;
  },
  volumeMuteToggle: () => muted.value = !muted.value,
  fastForward: e => {
    const baseSpeed = DEFAULT_SEEK_SPEED * (e.code === 'KeyL' ? 2 : 1);
    seek(e.shiftKey ? baseSpeed * 2 : baseSpeed);
  },
  fastBackward: e => {
    const baseSpeed = -DEFAULT_SEEK_SPEED * (e.code === 'KeyJ' ? 2 : 1);
    seek(e.shiftKey ? baseSpeed * 2 : baseSpeed);
  },
  nextTrack: () => emit('go-to-next-episode'),
});

useEventListener('keydown', (event: KeyboardEvent) => {
  if (event.code === 'KeyF' && !event.shiftKey && !event.ctrlKey) {
    toggleFullscreen();
  }
});


//
// Показывать/скрывать контрол бар в зависимости от активности пользователя
const {idle} = useIdle(3 * SECOND_MS);
const controlsVisible = computed(() => !playing.value || !idle.value);

watch(controlsVisible, controlsVisible => emit('update:controlsVisible', controlsVisible));

/**
 * Media Session Actions
 */
useMediaSessionActionsHandlers(
  computed<UseMediaSessionHandlers>(() => ({
    play: () => playing.value = true,
    seekto: (details => console.log({details})),
    pause: () => playing.value = false,
    seekbackward: () => seek(-DEFAULT_SEEK_SPEED),
    seekforward: () => seek(DEFAULT_SEEK_SPEED),
    nexttrack: props.hasNextEpisode ? () => emit('go-to-next-episode') : undefined,
  })),
);

let frames = ref({
  step: 0,
  map: new Map<number, string>(),
});
if (isTimelineThumbnailsEnabled()) {
  const minimalQualityVideo = computed(() =>
    props.video
      ? props.video.qualities.get(Math.min(...props.video.qualities.keys()))
      : undefined,
  );

  const loadFrames = async (times: number[], signal: AbortSignal, src: string) => {
    const framesIterator = getFramesFromVideo(times, src);
    for await (const {time, data} of framesIterator) {
      if (signal.aborted) {
        break;
      }
      frames.value.map.set(time, data);
    }
  };

  let controller: AbortController;
  onUnmounted(() => controller && !controller.signal.aborted && controller.abort());


  watchEffect(() => {
    if (controller) {
      controller.abort();
    }

    if (!$duration.value || !minimalQualityVideo.value) {
      return;
    }

    const frameLoadingStart = performance.now();

    frames.value.map.clear();
    frames.value.step = $duration.value >= HOUR ? 60 : 30;
    const chunks = 3;

    const totalSteps = $duration.value / frames.value.step;
    const stepPerChunk = totalSteps / chunks;
    const timeChunks: number[][] = [];
    for (let time = 0; time + frames.value.step / 2 < $duration.value; time += frames.value.step) {
      const chunkIndex = Math.floor((time / frames.value.step) / stepPerChunk);
      if (!Array.isArray(timeChunks[chunkIndex])) {
        timeChunks[chunkIndex] = [];
      }
      timeChunks[chunkIndex].push(Math.floor(time + frames.value.step / 2));
    }

    controller = new AbortController();

    Promise.all(
      timeChunks.map(times => minimalQualityVideo.value ? loadFrames(
        times,
        controller.signal,
        minimalQualityVideo.value) : Promise.resolve()),
    )
      .then(() => {
        trackTime(
          'Video timeline Frames',
          `Time to all frames loaded (chunks=${chunks} step=${frames.value.step})`,
          performance.now() - frameLoadingStart,
        );
        console.log('Все фреймы загружены', performance.now() - frameLoadingStart);
      });
  });
}

/**
 * Перед закрытием плеера необходимо:
 * - Остановить воспроизведение
 * - Выйти из режима картинка в картинке
 * - Выйти из полноэкранного режима
 * - Удалить служебные теги созданные для кэша
 */
onBeforeUnmount(() => {
  videoElement.value?.pause();

  if (document.pictureInPictureElement) {
    document.exitPictureInPicture();
  }

  if (document.fullscreenElement) {
    emit('update:inFullscreen', false);
  }

  document.head.querySelectorAll('video').forEach(e => e.remove());
});

const onProgressHandler = () => {
  if (videoElement.value?.duration && !isNaN(videoElement.value.duration) && isFinite(videoElement.value?.duration)) {
    emit('update:currentTime', videoElement.value?.currentTime);
    emit('update:duration', videoElement.value?.duration);
  }
};


</script>

<template>
  <div
    ref="videoPlayerRoot"
    class="component-root"
    :class="{hideCursor: inFullscreen && idle}"
  >
    <loading-spinner v-if="waiting || !isVideoLoaded" />
    <video
      ref="videoElement"
      preload="auto"
      autoplay
      crossorigin="anonymous"
      @click="playing = !playing"
      @dblclick="toggleFullscreen"
      @progress="onProgressHandler"
      @ended="$emit('go-to-next-episode')"
    >
      <source
        :src="videoSource"
        @error="errorHandler"
      >
    </video>
    <lib-ass-subtitles-renderer
      v-if="tracks.length > 0 && isSubtitlesEnabled"
      :time="$currentTime"
      :track="tracks[0]"
      :video-element="videoElement"
      :playing="playing"
      :waiting="waiting"
    />
    <transition name="fade">
      <section
        v-if="controlsVisible"
        class="control-panel absolute grid bottom-0 w-full text-white"
      >
        <progress-bar
          v-model:time="$currentTime"
          :frames="frames"
          class="progress-bar-container"
          :duration="$duration"
          :buffered="buffered"
        />

        <button
          class="play-button win-icon"
          :title="`${playing ? 'Пауза' : 'Смотреть'} (k)`"
          :aria-label="`${playing ? 'Пауза' : 'Смотреть'} (k)`"
          @click="playing = !playing"
        >
          {{ playing ? '&#xE769;' : '&#xE768;' }}
        </button>

        <button
          :disabled="!hasNextEpisode"
          class="next-button win-icon"
          title="Следующий эпизод"
          aria-label="Следующий эпизод"
          @click="$emit('go-to-next-episode')"
        >
          &#xE893;
        </button>

        <volume-control
          v-model:muted="muted"
          v-model:volume="volume"
          class="volume-control"
        />

        <time-code
          class="time-code"
          :current-time="$currentTime"
          :duration="$duration"
        />

        <button
          v-if="tracks.length > 0"
          title="Субтитры"
          aria-label="Субтитры"
          class="subtitles"
          @click="isSubtitlesEnabled = !isSubtitlesEnabled"
        >
          <span
            class="win-icon"
            :style="!isSubtitlesEnabled ? 'opacity: 0.5' : ''"
            aria-hidden="true"
          >
            &#xED1E;
          </span>
        </button>

        <select
          v-if="qualities.length > 0"
          v-model="selectedQuality"
          title="Качество видео"
          aria-label="Качество видео"
          class="settings w-auto px-1 py-0"
        >
          <option
            v-for="quality of qualities"
            :key="quality"
            :value="quality"
          >
            {{ quality }}p
          </option>
        </select>


        <toggle-pip-button
          class="picture-in-picture"
          :video="videoElement"
        />

        <button
          :title="`${inFullscreen ? 'Выход из полноэкранного режима' : 'Во весь экран'} (f)`"
          :aria-label="`${inFullscreen ? 'Выход из полноэкранного режима' : 'Во весь экран'} (f)`"
          class="toggle-fullscreen-button win-icon"
          @click="toggleFullscreen"
        >
          {{ inFullscreen ? '&#xE73F;' : '&#xE740;' }}
        </button>
      </section>
    </transition>
    <slot v-if="controlsVisible" />
  </div>
</template>

<style scoped>
@import "video-control-button.css";

.component-root {
  height: 100%;
  display: flex;
  flex-direction: column;
}

video {
  flex-grow: 1;
  min-width: 0;
  min-height: 0;
}

.hideCursor {
  cursor: none;
}


/**
 Панель управления
 */

.control-panel {
  --control-panel-bottom-padding: 8px;
  --control-panel-left-padding: 10px;
  --control-panel-right-padding: 10px;
  @apply absolute grid bottom-0 w-full text-white z-1;
  grid-template-columns: repeat(4, min-content) 1fr repeat(4, min-content);
  grid-template-rows: 15px min-content;
  gap: 5px 10px;
  grid-template-areas:
    "progress-bar progress-bar progress-bar progress-bar progress-bar progress-bar progress-bar progress-bar progress-bar"
    "play-button next-button volume-area time space subtitles settings picture-in-picture fullscreen";
  padding: 0 var(--control-panel-right-padding) var(--control-panel-bottom-padding) var(--control-panel-left-padding);
}

.control-panel, .control-panel > * {
  text-shadow: 1px 1px 1px black;
}


.control-panel > * {
  z-index: 1;
}


.control-panel:before {
  background: linear-gradient(transparent, rgba(0, 0, 0, .75));
  bottom: 0;
  content: "";
  height: 140%;
  left: 0;
  position: absolute;
  width: 100%;
  z-index: 0;
}


.progress-bar-container {
  grid-area: progress-bar;
}


.play-button {
  grid-area: play-button;
}

.next-button {
  grid-area: next-button;
}

.volume-control {
  grid-area: volume-area;
}


.toggle-fullscreen-button {
  grid-area: fullscreen;
}

.time-code {
  grid-area: time;
}

.settings {
  grid-area: settings;
  border: none;
  background: none;
  color: inherit;
  cursor: pointer;
}

.settings:hover {
  background: rgba(255, 255, 255, 0.2);
  border-radius: 3px;
}

select.settings option {
  background: rgba(0, 0, 0, 0.8);
}

.picture-in-picture {
  grid-area: picture-in-picture;
}

.subtitles {
  grid-area: subtitles;
}

</style>
